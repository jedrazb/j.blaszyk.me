{"componentChunkName":"component---src-templates-tech-blog-post-js","path":"/tech-blog/exploring-apache-lucene-scale/","result":{"data":{"site":{"siteMetadata":{"title":"Jedr's Blog","author":"Jedr Blaszyk","siteUrl":"https://j.blaszyk.me"}},"mdx":{"id":"fb4f11e3-21ca-5981-859b-0210cea853cf","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Exploring Apache Lucene - Part 3: Running at Scale\",\n  \"date\": \"2023-09-16\",\n  \"spoiler\": \"Exploring strategies to scale up Apache Lucene to serve high-traffic applications. Looking at how serverless architectures can enable cost-effective scalability.\",\n  \"images\": [\"./elastic-stateless.png\", \"./nrtsearch-architecture.png\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar ImageComponent = makeShortcode(\"ImageComponent\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Let\\u2019s explore real-world solutions that enable us to deploy and operate Apache Lucene at scale and discuss the advantages that a stateless architecture offers when managing shifting traffic patterns.\"), mdx(\"p\", null, \"If you are interested in Apache Lucene, I\\u2019m linking below other posts from the \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"Exploring Apache Lucene\"), \" series where I\\u2019m discussing its architecture in a bottom-up manner:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/tech-blog/exploring-apache-lucene-index/\"\n  }, \"Exploring Apache Lucene - Part 1: The Index\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/tech-blog/exploring-apache-lucene-search-and-ranking/\"\n  }, \"Exploring Apache Lucene - Part 2: Search and Ranking\"))), mdx(\"h2\", {\n    \"id\": \"lucene-at-scale\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#lucene-at-scale\",\n    \"aria-label\": \"lucene at scale permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Lucene at scale\"), mdx(\"p\", null, \"As search volumes and datasets grow, maintaining high performance with Apache Lucene can become increasingly challenging. As a result, scaling Lucene-based search engines becomes a crucial consideration for data-driven businesses. There are several open-source implementations that can help achieve this goal. I\\u2019m personally familiar with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/elastic/elasticsearch\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }, \"Elasticsearch\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/Yelp/nrtsearch\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }, \"nrtSearch\"), \", and I will use them to talk about different architectures.\"), mdx(\"p\", null, \"Both Elasticsearch and nrtSearch allow you to scale out Lucene across multiple nodes, with an added API wrapper for data ingestion and search. But their different designs and architectures make the problem of running Lucene at scale quite interesting. While they all aim to solve the same problem, their specific implementations have different tradeoffs in terms of performance, scalability, and ease of use.\"), mdx(\"p\", null, \"Let\\u2019s start with discussing the foundations.\"), mdx(\"h3\", {\n    \"id\": \"data-distribution\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#data-distribution\",\n    \"aria-label\": \"data distribution permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Data distribution\"), mdx(\"p\", null, \"If your searches are starting to take longer or your index is getting too large for a node to handle, it might be time to consider distributing your data across multiple nodes.\"), mdx(\"p\", null, \"To do this, you can divide your index into smaller partitions, called shards, which can then be distributed across separate nodes. A search engine can partition a search query into sub-searches that are run on each shard, and then the results are combined - this is known as \", mdx(\"em\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"em\",\n    \"href\": \"https://www.enterpriseintegrationpatterns.com/patterns/messaging/BroadcastAggregate.html\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }, \"Scatter-gather\")), \".\"), mdx(\"p\", null, \"The underlying technical details of index sharding are typically invisible to end users. They\\u2019ll simply experience faster search performance, especially when working with very large indexes. By distributing your data, you can overcome physical limitations and improve search efficiency.\"), mdx(\"h3\", {\n    \"id\": \"data-replication\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#data-replication\",\n    \"aria-label\": \"data replication permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Data replication\"), mdx(\"p\", null, \"When you have large search volumes that can\\u2019t be handled by a single node, you can distribute searches across multiple read-only copies of the index to improve search performance. By replicating the index, search queries can be processed concurrently across multiple nodes, resulting in faster response times for end-users. This makes it possible to handle large volumes of data and queries, which is critical for building a high-performing, scalable search engine.\"), mdx(\"p\", null, \"Data replication implies keeping the primary node in sync with all of its replicas and can increase the ingestion overhead. High volumes of indexing can consume extra resources and effectively reduce search performance.\"), mdx(\"p\", null, \"There are two main approaches to supporting data replication in Lucene:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.microsoft.com/en-us/research/publication/pacifica-replication-in-log-based-distributed-storage-systems/\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }, \"document replication\"), \": each replica indexes documents into index segments. A given quorum of replicas has to acknowledge the success of the insertion request for it to be considered successful by the primary.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://blog.mikemccandless.com/2017/09/lucenes-near-real-time-segment-index.html\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }, \"segment replication\"), \": only the primary ingests documents; new index segments are transferred to all replicas. This approach comes with less overhead as only the primary actually indexes the data; it guarantees point-in-time consistency.\")), mdx(\"p\", null, \"With \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"document-based replication\"), \", primary and replica shards are constantly communicating to stay in sync. They do this by replicating the operations performed on the primary shard to the replica shard, which means that the cost of those operations (CPU, mainly) is incurred for each replica specified. The same shards and nodes doing this work for ingest are also serving search requests, so provisioning and scaling must be done with both workloads in mind.\"), mdx(\"p\", null, \"With \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"segment-based replication\"), \", you can separate indexing and searching by replicating the index. This allows you to distribute indexing and searching across different nodes, which can help improve search performance and reduce the load on any one node. The approach effectively trades higher CPU consumption by the replicas for increased network consumption (transferring whole segments to replicas). By separating indexing and searching, you can ensure that your search engine remains performant and responsive, even as your indexing needs grow.\"), mdx(\"h3\", {\n    \"id\": \"load-balancing\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#load-balancing\",\n    \"aria-label\": \"load balancing permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Load balancing\"), mdx(\"p\", null, \"When your Lucene-powered search system experiences increased traffic, maintaining consistent performance becomes crucial. Some distributed search engines, such as Elasticsearch, come with their own built-in node discovery and load balancing mechanisms. These can either replace or complement traditional load balancers like Nginx or HAProxy. By intelligently distributing the workload across multiple nodes, these systems ensure that no single node is overwhelmed, resulting in a responsive and reliable search experience for users.\"), mdx(\"p\", null, \"Through load balancing, your search infrastructure gains the ability to scale horizontally: you can dynamically add or remove nodes without disrupting service availability.\"), mdx(\"p\", null, \"Load balancers often integrate health checks, monitoring the health of individual nodes and automatically directing traffic away from underperforming or unavailable nodes. By eliminating single points of failure and maximizing resource efficiency, load balancing contributes significantly to reliability and scalability.\"), mdx(\"h2\", {\n    \"id\": \"scaling-effectively\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#scaling-effectively\",\n    \"aria-label\": \"scaling effectively permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Scaling Effectively\"), mdx(\"p\", null, \"One common issue encountered in distributed systems is the time it takes for a new node to join the cluster and become fully operational. This delay can impact immediate responsiveness during peak traffic periods. To mitigate this challenge, the resources are often over-provisioned to ensure adequate capacity for traffic spikes or region failovers. However, over-provisioning can lead to unnecessary costs and waste of resources during non-peak times.\"), mdx(\"h3\", {\n    \"id\": \"stateless-deployment\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#stateless-deployment\",\n    \"aria-label\": \"stateless deployment permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Stateless Deployment\"), mdx(\"p\", null, \"Historically, most of Lucene deployments have been stateful. Nodes in such deployments heavily rely on local disks, and scaling often meant managing complex data transfer and node synchronization mechanisms. However, as the software ecosystem evolves towards more modular and scalable patterns, \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"stateless\"), \" is emerging as a preferred approach for deploying large-scale applications, including search.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The future is stateless.\")), mdx(\"p\", null, \"According to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.elastic.co/search-labs/stateless-your-new-state-of-find-with-elasticsearch\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }, \"Stateless \\u2014 your new state of find with Elasticsearch\"), \" blog.\"), mdx(\"p\", null, \"While Lucene itself inherently deals with indexed data stored on disk, modern deployment techniques can introduce a form of statelessness in distributed search engines built on Lucene. The stateless architecture might involve moving the persistent layer from local disc to external storage solutions like Amazon S3, while the search nodes themselves are kept stateless.\"), mdx(\"p\", null, \"Stateless containers, housing individual Lucene instances, can be rapidly spun up or down to match demand. For example, Kubernetes\\u2019 dynamic scaling and automated workload distribution can ensure that new nodes are ready to serve traffic swiftly, eliminating the need for excessive resource reservation. This approach optimizes resource utilization, reduces costs, and enables your search cluster to seamlessly handle varying workloads.\"), mdx(\"p\", null, \"For instance, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://engineeringblog.yelp.com/2021/09/nrtsearch-yelps-fast-scalable-and-cost-effective-search-engine.html\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }, \"Nrtsearch: Yelp\\u2019s Fast, Scalable and Cost Effective Search Engine\"), \" blog post highlights the advantages they gained from transitioning to a stateless Lucene-based search engine. The significant cost benefits stemmed primarily from the system\\u2019s capability to swiftly auto-scale in response to fluctuating user traffic.\"), mdx(\"h3\", {\n    \"id\": \"managed-serverless-in-the-cloud\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#managed-serverless-in-the-cloud\",\n    \"aria-label\": \"managed serverless in the cloud permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Managed Serverless in the Cloud\"), mdx(\"p\", null, \"The evolution of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.elastic.co/what-is/serverless-computing\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }, \"serverless architecture\"), \" has reached a new level, with cloud providers offering fully managed serverless services. With these services, users no longer need to concern themselves with the underlying infrastructure, such as provisioning, scaling, and maintenance. This shift allows developers to focus solely on building search functionalities and user experiences.\"), mdx(\"h3\", {\n    \"id\": \"scaling-efficiently-and-cost-effectively\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#scaling-efficiently-and-cost-effectively\",\n    \"aria-label\": \"scaling efficiently and cost effectively permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Scaling Efficiently and Cost-effectively\"), mdx(\"p\", null, \"Stateless architectures simplify auto-scaling and minimize wasted resources. This flexibility often leads to substantial cost savings for the developer. Although moving to a stateless approach can introduce challenges, such as data consistency issues, the financial and operational advantages typically outweigh the drawbacks.\"), mdx(\"h2\", {\n    \"id\": \"elasticsearch\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#elasticsearch\",\n    \"aria-label\": \"elasticsearch permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Elasticsearch\"), mdx(\"h3\", {\n    \"id\": \"architecture\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#architecture\",\n    \"aria-label\": \"architecture permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Architecture\"), mdx(\"p\", null, \"Elasticsearch runs on a stateful setup with a cluster at the core of its architecture. A cluster is a group of interconnected nodes that collectively manage and serve data. There are different types of nodes: data nodes store data, master-eligible nodes decide which node is in charge, and coordinating nodes manage search queries. Data in Elasticsearch is split into parts called \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"shards\"), \". This makes it easy to spread data across many nodes and grow the system.\"), mdx(\"p\", null, \"Primary shards handle data writing and manage copies called replicas. Replicas are backups; if one shard has an issue, a replica takes over. Coordinating nodes receive search requests, send them to the right shards, and calculate the answers. They don\\u2019t hold data, but they manage the flow of search requests. Data is organized into different lifecycle stages for efficient storage and access: \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"hot\"), \" for frequently accessed data, \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"cold\"), \" for less frequently accessed data, and \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"frozen\"), \" for archival data. Nodes can be specifically configured or optimized to handle data at each of these stages.\"), mdx(\"p\", null, \"In a real-world scenario where Elasticsearch was used for a search application with heavy user traffic, I\\u2019ve witnessed several issues with that setup:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Document-based replication issues\"), \": In Elasticsearch, each replica indexes documents individually. This means that as you scale out with more replicas, CPU demands for indexing increase, leading to escalated costs.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Shard distribution issues\"), \": Elasticsearch\\u2019s automatic shard distribution can lead to \\u201Chot\\u201D nodes (overwhelmed with traffic) and \\u201Ccold\\u201D nodes (underutilized). Sometimes manual intervention is needed to ensure a balanced spread of shards for optimized CPU usage.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Autoscaling Issues\"), \": Real-time scaling is challenging due to the need to migrate shards between nodes, causing provisioning for peak capacity. The necessity for a balanced shard distribution complicates autoscaling further, as scaling adjustments (number of new nodes joining the cluster) must align with the number of shards and replicas in each index.\"))), mdx(\"h3\", {\n    \"id\": \"stateful-and-stateless\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#stateful-and-stateless\",\n    \"aria-label\": \"stateful and stateless permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Stateful and stateless\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.elastic.co/search-labs/stateless-your-new-state-of-find-with-elasticsearch\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }, \"Elasticsearch is transitioning towards a stateless architecture\"), \", marking a significant departure from its traditional stateful design. In this new model, data persistence moves from local node disks to external blob storage platforms such as AWS S3. By doing so, there is no need for duplicating indexing across replica nodes, and it significantly reduces associated costs. Elasticsearch is evolving its operational structure: instead of mixing indexing and search operations on the same instances, they\\u2019ll be separated into distinct tiers. This separation means each function, indexing and searching, can scale based on its specific needs, enhancing both efficiency and performance.\"), mdx(ImageComponent, {\n    image: props.frontmatter.images[0],\n    alt: \"Elastic stateless architecture\",\n    mdxType: \"ImageComponent\"\n  }), mdx(\"h2\", {\n    \"id\": \"nrtsearch\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#nrtsearch\",\n    \"aria-label\": \"nrtsearch permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Nrtsearch\"), mdx(\"p\", null, \"While working as a software engineer at Yelp, I was part of the Ranking Platform team. We were at the core of an initiative to revamp the core search and ranking infrastructure in terms of performance and cost efficiency. This effort resulted in an open-source project - \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/Yelp/nrtsearch\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }, \"nrtsearch\"), \" - which, as of 2023, is used for the majority of search and ranking use cases at Yelp. You can read more about the nrtsearch project results in the blog post from Yelp\\u2019s Engineering Blog:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://engineeringblog.yelp.com/2021/09/nrtsearch-yelps-fast-scalable-and-cost-effective-search-engine.html\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }, \"Nrtsearch: Yelp\\u2019s Fast, Scalable and Cost Effective Search Engine\"))), mdx(\"p\", null, \"If you are interested in running the nrtsearch multi-node cluster locally, you can refer to the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://nrtsearch.readthedocs.io/en/latest/docker_compose.html\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }, \"official docs\"), \" or follow: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/tech-blog/nrtsearch-tutorial-website-search/\"\n  }, \"Nrtsearch Tutorial - Indexing Web Content for Search\"), \" with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/jedrazb/nrtsearch-tutorial-website-search\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }, \"the tutorial repo\"), \".\"), mdx(\"h3\", {\n    \"id\": \"stateless-architecture\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#stateless-architecture\",\n    \"aria-label\": \"stateless architecture permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Stateless architecture\"), mdx(ImageComponent, {\n    image: props.frontmatter.images[1],\n    alt: \"Nrtsearch architecture\",\n    mdxType: \"ImageComponent\"\n  }), mdx(\"p\", null, \"Nrtsearch is a search engine developed with specific design goals, including utilizing Lucene\\u2019s capabilities and ensuring near-real-time segment replication. Nrtsearch is built on Lucene, which enables the reuse of custom Java code for features like ML-based ranking, analysis, highlighting, and suggestions.\"), mdx(\"p\", null, \"The cluster is at the core of its architecture. It consists of a single primary and replicas.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Primary node\"), \" - a single node, responsible for data indexing. It periodically publishes Lucene segment updates to replicas. Hence the name: \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"nrtsearch - near-real time search\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Replica nodes\"), \" - one or more nodes, responsible for serving the search traffic. It receives periodic segment updates from the primary. The number of running replicas can be controlled by an auto-scaler (like \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }, \"HPA\"), \") to respond to changing search load.\")), mdx(\"p\", null, \"Instead of relying on a node\\u2019s local storage, the primary copy of the index is stored externally, such as on Amazon S3. This setup ensures nodes can be swiftly rebooted without the need for local instance storage backups. The primary carries out the bulk of the work. When the primary indexes documents, it sends updates to all replicas. Replicas receive the latest segments from the primary over the network. This method effectively trades higher CPU consumption by the replicas for increased network consumption, as replicas don\\u2019t need index documents to Lucene segments on their own. However, with high networking bandwidth becoming more affordable over time, this is a feasible approach. The near-real-time segment replication offers point-in-time consistency.\"), mdx(\"p\", null, \"Nrtsearch doesn\\u2019t include a transaction log. Clients are expected to periodically call \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"commit\"), \" to persist recent changes. If a primary node crashes, documents indexed since the last commit might be lost, but an external ETL system, like Flink, can revert to a checkpoint and resend indexing requests.\"), mdx(\"p\", null, \"Outside of Nrtsearch, Kubernetes helps in addressing deployment challenges, such as replacing a failed primary or replica pod. Load balancing across replicas is managed on the client-side with gRPC load balancing.\"), mdx(\"p\", null, \"In cases where data doesn\\u2019t fit onto a single primary (index size > 30GB), the index can be divided across multiple clusters. Each of these clusters has its own primary and a set of replicas. To manage such a distributed setup efficiently, a scatter-gather service needs to be used - unfortunately, it has not been open-sourced by Yelp as of 2023. This service coordinates both indexing across clusters and distributed querying. When a query is made, it\\u2019s scattered across the clusters, and each cluster processes its portion of the query. Once processed, the results are gathered and combined before being returned to the user.\"), mdx(\"p\", null, \"Nrtsearch was built for cost-saving and easy auto-scaling. However, it\\u2019s not as user-friendly as some alternatives. Unlike Elastic\\u2019s stack with open-source tools like Kibana, nrtsearch doesn\\u2019t have as many tutorials, user docs, or publicly available scatter-gather and k8s operator service. So, while it does its main job well, you might need more setup and integration work to get everything running smoothly.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#lucene-at-scale","title":"Lucene at scale","items":[{"url":"#data-distribution","title":"Data distribution"},{"url":"#data-replication","title":"Data replication"},{"url":"#load-balancing","title":"Load balancing"}]},{"url":"#scaling-effectively","title":"Scaling Effectively","items":[{"url":"#stateless-deployment","title":"Stateless Deployment"},{"url":"#managed-serverless-in-the-cloud","title":"Managed Serverless in the Cloud"},{"url":"#scaling-efficiently-and-cost-effectively","title":"Scaling Efficiently and Cost-effectively"}]},{"url":"#elasticsearch","title":"Elasticsearch","items":[{"url":"#architecture","title":"Architecture"},{"url":"#stateful-and-stateless","title":"Stateful and stateless"}]},{"url":"#nrtsearch","title":"Nrtsearch","items":[{"url":"#stateless-architecture","title":"Stateless architecture"}]}]},"timeToRead":8,"frontmatter":{"title":"Exploring Apache Lucene - Part 3: Running at Scale","date":"September 16, 2023","spoiler":"Exploring strategies to scale up Apache Lucene to serve high-traffic applications. Looking at how serverless architectures can enable cost-effective scalability.","ogimage":null,"images":[{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB50lEQVQoz0VQ7W7TQBDME/ECPB68BA8CEqqQ+AGtoIikLWna1E2c+HznvU/7zs75424PGVJY7UqzqxnNaBe89rf32afPX5d3W9CnStYgdCUdA8PAVGCASQmaiYapdr5Lx1T7txdMuuXj7tv6YbXeFuCW+fF79otBQ0UDomGVKgqyzW6h5KWyB+NK7ag894Kp1ngvveeu31duQ/hNnu/B7Su1ebrlwj5TcbnPoWDCNM3gjff/xWBOD0wcyHOp3YG3B8p2xaGQflWo62OWU0V4fZSaUGnaLt88K9Mw3b04y3bDTSYoUfUBuuvd8TK7y2ldgCkp5FW/e3ivL14zQqu631BOtKPClcKWwi5At7rplR157bnpjtxkBOY/zZ+reROOu+XdxdtKNUx1XHeVasF0oj6B7hYxotbmZrVSSk8hRkyIKUQMiNMLiGkGMWKcCdj6sW7sMI6LlLDg8EhIxQFjTHPhPNiniZ5XDCmlMaH9w+isI4T43i9SStpaJviUUsAEtWQ6Dym54oP/+CoNth/HvNpiGLuh51L6EDCdaxb/KOCpWLejR0yltY8CYkw/IXvz5V2YBj8M95KPYXBtl62zHiPOufAsbjHqYejDnC0MQ1/rOI60tlcFi4gY43Dyc2yMOkxT+mecfgM0+GObPTWSmQAAAABJRU5ErkJggg=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/d33428636dee4b2dc7c4a09ff2f5ac2c/72368/elastic-stateless.png","srcSet":"/static/d33428636dee4b2dc7c4a09ff2f5ac2c/2479c/elastic-stateless.png 750w,\n/static/d33428636dee4b2dc7c4a09ff2f5ac2c/f45fa/elastic-stateless.png 1080w,\n/static/d33428636dee4b2dc7c4a09ff2f5ac2c/fc4d4/elastic-stateless.png 1366w,\n/static/d33428636dee4b2dc7c4a09ff2f5ac2c/72368/elastic-stateless.png 1400w,\n/static/d33428636dee4b2dc7c4a09ff2f5ac2c/c694b/elastic-stateless.png 1822w","sizes":"(min-width: 1400px) 1400px, 100vw"},"sources":[{"srcSet":"/static/d33428636dee4b2dc7c4a09ff2f5ac2c/cc1d9/elastic-stateless.webp 750w,\n/static/d33428636dee4b2dc7c4a09ff2f5ac2c/05669/elastic-stateless.webp 1080w,\n/static/d33428636dee4b2dc7c4a09ff2f5ac2c/60efe/elastic-stateless.webp 1366w,\n/static/d33428636dee4b2dc7c4a09ff2f5ac2c/be3c0/elastic-stateless.webp 1400w,\n/static/d33428636dee4b2dc7c4a09ff2f5ac2c/15840/elastic-stateless.webp 1822w","type":"image/webp","sizes":"(min-width: 1400px) 1400px, 100vw"}]},"width":1400,"height":782}}},{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAACmElEQVQ4y51TaW8TMRDN//87gKACibagVkCvXG2yySbZw3ukyd6H4yMPjdvdBsQnRnra8ez4zXj8PDgej+iMfIKUEkKIHkopaK1NnPy/8zufbNAtOOeo6xpVVSFN0z+QZZlBURTmf1mWpsApaYdBx0yJtCnPc2w2G2wcB5uNA8dx4PsMnuchimJTlHKapsG/rCekitRl+UpMG2lT1zX5HWhNuZPJBHEc9/tPOuxAR9AIGEOeZ8bXND+lIKTsj6m0NmsqXjcNhJCmEM13oDQQJQJhIhEmAmzHEaUScaYQJRLBXoBLgDH/pcPAQ7a0UKyXKDcrFPYCbRyaIoawKBtYPsciUJh5HD8nEa6HPqbrCstQYeYLPKccURggiiLshndg388x/fQeT2cfEF5dYDcdIS9Lo4JB3bSmC7YTYHsJb8ux9HM4UYNgL8H2CvEux3g8AmMM2dpGtpghsZ4MMoKzRl4UqKsKA9LZ6VBp2MzMMO+1JaXAarXCdrtF7qyR2RZS20JmL5At52ji0MyURmIID4eDuTki2e/3vXxIb92wyZq6xvb+Buz7V0w/vjNHjq4u8DwZoqgqtERIHXWCTZIEruvC932EYdhrjgp2Vgc+irWNgi7EwEbBPLScv3WotXrVWI22bXv9EYisewX6qHEqsjexvbwYyh3wlkMrDSU1pFA4cAGtjvgfM4RSSUSphzBxEWe+8en7XATmS/H2UENIjiBxTGybM/OfQL7JS13UDd2yOmDOhpgHQ9xZ1/h2/wWXd59xPT43sYl7g7xO0PASY/cX5sEIPx4vTd75zRlurSsTm7q3KKqMOhSwo0cswgksNsbMG2LmPWDuj7CMpqZY2WSmyxl7eIn5I5P35D2YPctwCisY4yBa/AZdacAmLkoC1QAAAABJRU5ErkJggg=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/e8325137c0bef5c1504bceba4ef434e3/e7469/nrtsearch-architecture.png","srcSet":"/static/e8325137c0bef5c1504bceba4ef434e3/17fec/nrtsearch-architecture.png 750w,\n/static/e8325137c0bef5c1504bceba4ef434e3/a00dd/nrtsearch-architecture.png 1080w,\n/static/e8325137c0bef5c1504bceba4ef434e3/fa7ad/nrtsearch-architecture.png 1366w,\n/static/e8325137c0bef5c1504bceba4ef434e3/e7469/nrtsearch-architecture.png 1400w,\n/static/e8325137c0bef5c1504bceba4ef434e3/4e08d/nrtsearch-architecture.png 1920w","sizes":"(min-width: 1400px) 1400px, 100vw"},"sources":[{"srcSet":"/static/e8325137c0bef5c1504bceba4ef434e3/603ae/nrtsearch-architecture.webp 750w,\n/static/e8325137c0bef5c1504bceba4ef434e3/7c76b/nrtsearch-architecture.webp 1080w,\n/static/e8325137c0bef5c1504bceba4ef434e3/a2c8d/nrtsearch-architecture.webp 1366w,\n/static/e8325137c0bef5c1504bceba4ef434e3/1e7fb/nrtsearch-architecture.webp 1400w,\n/static/e8325137c0bef5c1504bceba4ef434e3/90598/nrtsearch-architecture.webp 1920w","type":"image/webp","sizes":"(min-width: 1400px) 1400px, 100vw"}]},"width":1400,"height":1111}}}],"blogImages":null},"fields":{"slug":"/exploring-apache-lucene-scale/","category":"tech-blog"}}},"pageContext":{"slug":"/exploring-apache-lucene-scale/","previous":{"fields":{"slug":"/nrtsearch-tutorial-website-search/","directoryName":"nrtsearch-tutorial-website-search","category":"tech-blog"},"frontmatter":{"title":"Nrtsearch Tutorial - Indexing Web Content for Search"}},"next":{"fields":{"slug":"/elasticsearch-data-connectors/","directoryName":"elasticsearch-data-connectors","category":"tech-blog"},"frontmatter":{"title":"Elastic Data Connectors - Elasticsearch Ingestion Made Simple"}}}},"staticQueryHashes":["1142660440"]}