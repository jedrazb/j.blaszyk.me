{"componentChunkName":"component---src-templates-tech-blog-post-js","path":"/tech-blog/exploring-apache-lucene-index/","result":{"data":{"site":{"siteMetadata":{"title":"Jedr's Blog","author":"Jedr Blaszyk","siteUrl":"https://j.blaszyk.me"}},"mdx":{"id":"56d26a5e-5815-5c5a-8539-e732d68b9cd2","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Exploring Apache Lucene - Part 1: The Index\",\n  \"date\": \"2023-01-16\",\n  \"spoiler\": \"Exploring Apache Lucene's core concepts - inverted index, insertions and deletions.\",\n  \"blogImages\": [\"./inverted_index.png\", \"./lucene_segments.png\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar ImageComponent = makeShortcode(\"ImageComponent\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"When I joined Yelp in 2020, as a software engineer, I became part of the Ranking Platform team. The team is responsible for the development and maintenance of Yelp\\u2019s search and ranking infrastructure, a crucial part of our ecosystem, that allows for business search, reviews search and powers the internal real-time ad bidding system. At that time, I was part of an initiative to revamp our core search & ranking infra in terms of performance and cost efficiency. This effort resulted in an open-source project - \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/Yelp/nrtsearch\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }, \"nrtsearch\"), \" - which, as of early 2023, is used for the majority of search and ranking use cases at Yelp, with more migrations underway set to replace Elasticsearch. With nrtsearch our p50s, p95s and p99s improved by 30-50% while costs dropped by as much as 40% in some cases. You can read more about the nrtsearch project results in the blog post from Yelp\\u2019s Engineering Blog:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://engineeringblog.yelp.com/2021/09/nrtsearch-yelps-fast-scalable-and-cost-effective-search-engine.html\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }, \"Nrtsearch: Yelp\\u2019s Fast, Scalable and Cost Effective Search Engine\"))), mdx(\"p\", null, \"Nrtsearch development was led by senior folks, industry experts who know ins and outs of Apache Lucene - the core search library on top of which nrtsearch was built. I worked on well-scoped projects, like scalable ingestion, logging, plugin development and scatter-gather service, which allows for application-level cluster sharding. While I enjoyed those projects, I feel that, for a long time, I treated the nrtsearch core search functionality as a black-box - not fully understanding its internals. Therefore, I decided to take a step back, explore, and understand Apache Lucene - a search library at the core of nrtsearch and Elasticsearch (Elastic - a company built around Elasticsearch has a market cap of 5B$).\"), mdx(\"p\", null, \"This is the first tech blog post from the series \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Exploring Apache Lucene\"), \" in which I\\u2019ll describe, in the bottom-up manner, the building blocks of modern search engines.\"), mdx(\"h2\", {\n    \"id\": \"lucenes-jargon\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#lucenes-jargon\",\n    \"aria-label\": \"lucenes jargon permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Lucene\\u2019s jargon\"), mdx(\"p\", null, \"Before starting, I want to explain some terms closely linked to Apache Lucene. They don\\u2019t necessarily map 1:1 to other DB technologies, what is at times confusing when reading Lucene\\u2019s docs and related blog posts.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"document\"), \" - a record, the unit of search and index, a set of fields. Documents are added to a Lucene index, and can be retrieved by a search query.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"field\"), \" - a typed slot in a document. A field is a sequence of terms. Document can have multiple fields.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"term\"), \" - a value from the source document, the unit of search. Used for building the inverted index\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"index\"), \" - a collection of documents, typically with the same schema.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"inverted index\"), \" - an internal data structure that maps terms to documents by ID, efficient for text-search queries.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"stored fields\"), \" - an array of all field values per field, in document order, stored in index in non-inverted manner. Efficient for getting many field values for a few docs.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"doc values\"), \" - Lucene\\u2019s column-stride field value storage. Efficient for getting a few field values for many docs. Useful for sorting and faceting.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"index segments\"), \" - Lucene indexes may be composed of multiple sub-indexes, or segments. Each segment is a fully independent index, which could be searched separately.\")), mdx(\"h2\", {\n    \"id\": \"representing-data-with-lucene\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#representing-data-with-lucene\",\n    \"aria-label\": \"representing data with lucene permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Representing data with Lucene\"), mdx(\"h4\", {\n    \"id\": \"inverted-index\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#inverted-index\",\n    \"aria-label\": \"inverted index permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Inverted Index\"), mdx(\"p\", null, \"Inverted index is a data structure that maps terms (i.e. words or phrases) to the documents that contain them. The index is built by analyzing the text of the documents and extracting terms from them. The inverted index allows for fast and efficient searching by providing a way to look up documents that contain a specific term or set of terms. It also provides a way to rank the relevance of the search results by determining how many of the search terms match to a specific document.\"), mdx(\"p\", null, \"The inverted index is composed of two substructures:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"term dictionary\"), \" - groups all the terms included in the documents in a \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"sorted\"), \" list.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"postings list\"), \" - creates a list of each term, indicating the documents where the term appears.\")), mdx(ImageComponent, {\n    image: props.frontmatter.blogImages[0],\n    alt: \"Apache Lucene Inverted Index\",\n    mdxType: \"ImageComponent\"\n  }), mdx(\"p\", null, \"In the above example we can see three documents indexed into Lucene\\u2019s inverted index. Each of the document\\u2019s conten is analyzed (tokenized) into terms which are inserted into inverted index.\"), mdx(\"p\", null, \"Since the terms in the dictionary are sorted, we can quickly find a term (think binary search), and subsequently its occurrences in the postings-structure. This is contrary to a \\u201Cforward index\\u201D, which lists terms related to a specific document.\"), mdx(\"h4\", {\n    \"id\": \"docvalues\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#docvalues\",\n    \"aria-label\": \"docvalues permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"DocValues\"), mdx(\"p\", null, \"Inverted index builds a mapping of terms found in all the documents in the index to a list of documents that the term appears in. This makes search very fast - since users search by terms, having a ready list of term-to-document values makes the query process faster.\"), mdx(\"p\", null, \"For other features that are associated with search, such as sorting, faceting, and highlighting, this approach is not very efficient. The faceting engine, for example, must look up each term that appears in each document that will make up the result set and pull the document IDs to build the facet list.\"), mdx(\"p\", null, \"DocValue fields are column-oriented fields with a document-to-value mapping built at index time - an uninverted (forward) index. This approach can make lookups for faceting, sorting, and grouping much faster, as we can retrieve fields for multiple docs with the single disk seek (utilizing the filesystem cache).\"), mdx(\"p\", null, \"DocValues should be preferred over \\u201Cstored fields\\u201D unless the complete document is being retrieved by a query.\"), mdx(\"h4\", {\n    \"id\": \"stored-fields\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#stored-fields\",\n    \"aria-label\": \"stored fields permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Stored Fields\"), mdx(\"p\", null, \"Similar to DocValues, Stored fields have been created to effectively persist values (differently to how inverted index does it) of the document fields, and then, retrieve them when needed.\"), mdx(\"p\", null, \"Stored fields are organised in a row manner. This means that, given a set of fields, for each document, the values of these fields are concatenated in a row. The rows are then stored sequentially on disk according to their Lucene doc id. Each row may have a different size depending on the number of fields defined for that document and data types (e.g. string or text fields have variable sizes). The pointers to each row are stored for allowing fast access to them.\"), mdx(\"p\", null, \"This technique is particularly useful if our search query needs to return complete documents (with all their fields) rather than just a few fields.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DocValues\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Stored fields\"), \" approached are not mutually exclusive settings, a given field, apart from being indexed into the inverted index, can have DocValues and Stored fields enabled. The queries that will be run against the index should determine which of these approaches is used. It\\u2019s important to keep in mind that both of approached are effectively duplicating data and storing them in a format suitable for specific the access pattern - so enabling both may result in a bloated index size.\"), mdx(\"h3\", {\n    \"id\": \"insertions\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#insertions\",\n    \"aria-label\": \"insertions permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Insertions\"), mdx(\"p\", null, \"When building inverted indexes, we need to prioritize things like: search speed, index compactness, indexing speed and the time it takes for new changes to become visible. Search speed and index compactness are related: when searching over a smaller index, less data needs to be processed, and more of it will fit in memory. Both, particularly compactness, come at the cost of indexing speed.\"), mdx(\"p\", null, \"To minimize index sizes, various compression techniques are used. For example, when storing the postings (which can get quite large), Lucene does tricks like delta-encoding - e.g. \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"[1, 9, 420]\"), \" is stored as \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"[1, 8, 411]\"), \" - so small numbers can be saved with less bytes.\"), mdx(\"p\", null, \"When new documents are added, the index changes are first buffered in memory. Eventually, the index files in their entirety, are flushed to disk. The written files make up an index segment.\"), mdx(ImageComponent, {\n    image: props.frontmatter.blogImages[1],\n    alt: \"Apache Lucene Segment Merges\",\n    mdxType: \"ImageComponent\"\n  }), mdx(\"p\", null, \"Lucene index segments are \\u201Cwrite-once\\u201D files: once a segment has been written to permanent storage (to disk), it is never altered. This means that indexes are actually comprised of several files which are each subsets of the full index. To prevent eternal fragmentation of the index, segments are periodically merged. In the example above (\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://speakerdeck.com/elasticsearch/what-is-in-a-lucene-index?slide=11\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }, \"source\"), \") we have two segments, each consisting of a single document. On the right side of the image, we can see a result of a segment merge - where 2 segments are merged to form a new segment.\"), mdx(\"h3\", {\n    \"id\": \"deletions\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#deletions\",\n    \"aria-label\": \"deletions permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Deletions\"), mdx(\"p\", null, \"For each segment, Lucene maintains a per-segment bitset (vector of 0 and 1s). Flipping a bit from 1 to 0 signals to Lucene that a document is deleted. All subsequent searches simply skip any deleted documents. It is not until segments are merged that the bytes consumed by deleted documents are reclaimed, as after the merge the resulting segment won\\u2019t contain deleted documents. Deleting the documents in-place in the existing segment would be far too costly.\"), mdx(\"h3\", {\n    \"id\": \"updates\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#updates\",\n    \"aria-label\": \"updates permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Updates\"), mdx(\"p\", null, \"Updating a previously indexed document is a \\u201Ccheap\\u201D delete followed by a re-insertion of the document. This means that updating a document is even more expensive than adding it in the first place. Thus, storing things like rapidly changing values in a Lucene index is probably not a good idea \\u2013 there is no in-place update of values.\"), mdx(\"h3\", {\n    \"id\": \"visualising-lucenes-segment-merges\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#visualising-lucenes-segment-merges\",\n    \"aria-label\": \"visualising lucenes segment merges permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Visualising Lucene\\u2019s segment merges\"), mdx(\"p\", null, \"Below there is a visualisation of how Lucene handles insertions, deletion and segment merges (taken from this great \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://blog.mikemccandless.com/2011/02/visualizing-lucenes-segment-merges.html\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }, \"blog post\"), \" by Michael McCandless). Each segment is a bar, whose height is the size (in MB) of the segment. Segments on the left are the largest; as new segments are flushed, they appear on the right. The dark grey band on top of each segment shows the proportion of deletions in that segment.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/d354b960d0be76123bf1819fc104cf73/segment_merges.gif\",\n    \"alt\": \"Lucene segment merges\"\n  })), mdx(\"h3\", {\n    \"id\": \"lucenes-data-storage-architecture-pros-and-cons\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#lucenes-data-storage-architecture-pros-and-cons\",\n    \"aria-label\": \"lucenes data storage architecture pros and cons permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Lucene\\u2019s data storage architecture: pros and cons\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"(-) Document insertions require writing a new segment. Which can be costly for single-document insertions. Therefore bulk inserts are preferred.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"(+) Segments are never modified in-place, so they are filesystem cache-friendly. Segments can be searched concurrently lock-free, with no risk of race conditions. It also allows for concurrent query execution.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"(+) The inverted index allows for fast and efficient searching by providing a way to look up documents that contain a specific term or set of terms.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"(+) Terms compression. Deduplication of terms within a segment, it can save a lot of space for very high-frequency terms.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"(+) Terms are uniquely identified by an ordinal, useful for sorting and faceting.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"(+) DocValues optimization can help with efficient sorting and faceting. Stored fields can help with retrieving whole documents.\")), mdx(\"p\", null, \"Exploring Lucene series is continued in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/tech-blog/exploring-apache-lucene-search-and-ranking/\"\n  }, \"Exploring Apache Lucene - Part 2: Search and Ranking\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/tech-blog/exploring-apache-lucene-scale/\"\n  }, \"Exploring Apache Lucene - Part 3: Running at Scale\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#lucenes-jargon","title":"Lucene's jargon"},{"url":"#representing-data-with-lucene","title":"Representing data with Lucene","items":[{"items":[{"url":"#inverted-index","title":"Inverted Index"},{"url":"#docvalues","title":"DocValues"},{"url":"#stored-fields","title":"Stored Fields"}]},{"url":"#insertions","title":"Insertions"},{"url":"#deletions","title":"Deletions"},{"url":"#updates","title":"Updates"},{"url":"#visualising-lucenes-segment-merges","title":"Visualising Lucene's segment merges"},{"url":"#lucenes-data-storage-architecture-pros-and-cons","title":"Lucene's data storage architecture: pros and cons"}]}]},"timeToRead":6,"frontmatter":{"title":"Exploring Apache Lucene - Part 1: The Index","date":"January 16, 2023","spoiler":"Exploring Apache Lucene's core concepts - inverted index, insertions and deletions.","ogimage":null,"images":null,"blogImages":[{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACVElEQVQoz32T627aQBSE/f4v1B9NW1oSSAIJGF+wwV7b2GCDr0AgsYn5KjZRlV7UI61WO9odzZydo6RpijqZoGkaTd2Q5zl5ntG2LZc6n8//XB/rI64Evo9t23Q6HYQrOB6P7Pf7Px7wF8npdKKpa9rX199wxfc89ImGOh4TRRFVWVIUOcvlkiAIKMvy1+XD8UjdnCjKiiAMiZYrgkVImuU8HY60F4VlUZClKdkmpSoLdrs1nmexipaUeYmmjdhsfOI4Ymj7DGyfq9sRqlihL9bcmS63hovqxQxNByXLMsypKXtYv9TS2mazYWqabMsKIQRNU5PnBfemy8Ms4HPvgd5kxlgsuTcFYzdiGuXcjAwU13EkWbfbJQxDaS3PMmaWzWH/hCc8iVXbHXeGw8Nswef+I93RVKoc2gGan2CEKb3xFMXUDXrXN1LROkmoqoT5XGcdJ9Ce0bUxSSJYhB4Dy5cKr/qP3JmCiRdLhZf9jdBEiVcxwnGIwpAn+btn1utE/njzUuM4DqeL5aLg9oPCvu5IooHlofkxxuKd8JI7y7YxDEPG4FJlWeE6LvXxmcAPJLbbP9HXZozmIV9uRwymAiNYy75qXoy1zOmrUxTf97Esi16vTxSFbKsY1zHI04z9doeqPpAkrrT8bajTGU35dD2gbwh6huDr0OBGc7i3F3SGGoqh63S//0CbaDI+bXvicNiTJInMYppuaJoXTq8nVE3HER4T3WCkTsiKUmLWbM4mK+RZCYMFc3uGcF2KPOd/VdcvtO2rnJLn5+P7xDRvo/Q+KT8B0e912GDaRPwAAAAASUVORK5CYII="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/44d210cd5665d02788bd8d56c4670584/b5a77/inverted_index.png","srcSet":"/static/44d210cd5665d02788bd8d56c4670584/36d0b/inverted_index.png 750w,\n/static/44d210cd5665d02788bd8d56c4670584/b5a77/inverted_index.png 878w","sizes":"(min-width: 878px) 878px, 100vw"},"sources":[{"srcSet":"/static/44d210cd5665d02788bd8d56c4670584/2116b/inverted_index.webp 750w,\n/static/44d210cd5665d02788bd8d56c4670584/64c4a/inverted_index.webp 878w","type":"image/webp","sizes":"(min-width: 878px) 878px, 100vw"}]},"width":1400,"height":813.2118451025057}}},{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABQ0lEQVQoz3WRT0+DQBDF+f6fwHj2aKLe9GDTkzUa01pTldKWArvsLrBC+a8Cz8xqD8Y6ycvMYfJm5jdWlmWIogiMMWitEccxDsUwDOj7/ldt8tCbei8rSRKEYQjHcYwx5yHyXCNNBbJMQb9xtO8VmqaBUhLb7RZKKQRBgLZt/wy2pJRYr9eYzWam2fM88NCBvbyDs3rA4vkG2S5CXTfwfR/z+Ryu62KzccH5FozZRr7/Aik9WGmagkzpZNqWph+KsixNj22TQYA40nh8neB6eoKz0THOx0eYrkawDEMVmbOJIanrOsNmz4uiKAqzIaERQoAxDpUI6FJCaAaZMuxqDYueIEJhJlNNGy78e0yWl7i6PcX46QJq54P88zw3xlVVmdx9dn8Z0iOIG3HknBvlZYa0SBBpiSRVaD9q/BfD0P/o++NfcZ4PcLjYf7wAAAAASUVORK5CYII="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/b38de5c8d2ec4d693c531c60cf575fbe/14581/lucene_segments.png","srcSet":"/static/b38de5c8d2ec4d693c531c60cf575fbe/22baf/lucene_segments.png 750w,\n/static/b38de5c8d2ec4d693c531c60cf575fbe/9a257/lucene_segments.png 1080w,\n/static/b38de5c8d2ec4d693c531c60cf575fbe/cec2f/lucene_segments.png 1366w,\n/static/b38de5c8d2ec4d693c531c60cf575fbe/14581/lucene_segments.png 1400w,\n/static/b38de5c8d2ec4d693c531c60cf575fbe/bcf0a/lucene_segments.png 1920w","sizes":"(min-width: 1400px) 1400px, 100vw"},"sources":[{"srcSet":"/static/b38de5c8d2ec4d693c531c60cf575fbe/892b4/lucene_segments.webp 750w,\n/static/b38de5c8d2ec4d693c531c60cf575fbe/fd950/lucene_segments.webp 1080w,\n/static/b38de5c8d2ec4d693c531c60cf575fbe/1d353/lucene_segments.webp 1366w,\n/static/b38de5c8d2ec4d693c531c60cf575fbe/64bfe/lucene_segments.webp 1400w,\n/static/b38de5c8d2ec4d693c531c60cf575fbe/67c7c/lucene_segments.webp 1920w","type":"image/webp","sizes":"(min-width: 1400px) 1400px, 100vw"}]},"width":1400,"height":506}}}]},"fields":{"slug":"/exploring-apache-lucene-index/","category":"tech-blog"}}},"pageContext":{"slug":"/exploring-apache-lucene-index/","previous":{"fields":{"slug":"/geometric-deep-learning-overview/","directoryName":"geometric-deep-learning-overview","category":"tech-blog"},"frontmatter":{"title":"Geometric Deep Learning - an overview"}},"next":{"fields":{"slug":"/tech-stack-of-fast-free-and-customizable-blog/","directoryName":"tech-stack-of-fast-free-and-customizable-blog","category":"tech-blog"},"frontmatter":{"title":"The Tech Stack of Fast, Free, and Customizable Blog"}}}},"staticQueryHashes":["1142660440"]}